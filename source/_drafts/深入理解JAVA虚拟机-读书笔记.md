---
title: 深入理解JAVA虚拟机-读书笔记
categories:
- 读书笔记
tags:
- JVM
---

### 运行时数据区（内存结构）
#### 程序计数器
线程私有，记录当前线程执行的非navite方法的JVM指令地址
#### 虚拟机栈
线程私有，存储栈帧，一个方法对应一个栈帧。
栈帧包含：
* 局部变量
保存方法参数
* 操作数堆栈
Java虚拟机提供指令以将局部变量或字段中的常量或值加载到操作数堆栈上。其他Java虚拟机指令从操作数堆栈获取操作数，
对它们进行操作，并将结果推回操作数堆栈。操作数堆栈还用于准备要传递给方法和接收方法结果的参数。
* 动态链接
包含对运行时常量池的引用，该引用用于支持方法代码的动态链接的当前方法的类型。该class方法的文件代码是指要调用的方法和要通过符号引用访问的变量。
动态链接将这些符号方法引用转换为具体的方法引用
* 堆
线程之间共享的堆。堆是运行时数据区，从中分配所有类实例和数组的内存。
#### 方法区
线程之间共享,存储类结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化以及接口初始化中使用的特殊方法
#### 运行时常量池
存储类或接口的运行时常量表
#### 本地方法栈
native方法所用堆栈

### GC
#### 标记清理对象
可达性分析算法
对象是否


### 线程安全
> “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”

由于数据共享的原因导致多线程下可能出现问题
> 在java中基本类型加final即刻保证不可变，如果数据是对象，则需保证对象的行为不对其状态产生影响。
如String操作均是返回新对象，不对原对象进行修改。其内部的char数组也是final修饰的，Integer也是类似，这种对象的实例如果被final修饰就是安全的；
不可变的安全性简单纯碎，应用场景有限。

#### 实现方式
##### 互斥同步
同步
> 共享数据在同一时刻只能被一个线程使用。
互斥
> 实现同步的手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。

互斥是方法，同步是目的。
java中通过synchronized关键字实现同步
修饰方法时编译生成方法标识ACC_SYNCHRONIZED，这是由方法调用指令进行检查。调用方法时ACC_SYNCHRONIZED如果设置，则执行线程进入监视器，
调用方法本身，并退出监视器，方法调用是正常还是突然完成。在执行线程拥有监视器期间，没有其他线程可以输入它。
如果在调用synchronized方法期间抛出异常并且synchronized方法未处理异常，则在从方法重新抛出异常之前，将自动退出该方法的监视器synchronized
修饰方法块时编译生成monitorenter和monitorexit指令，两个指令从栈获取监视对象的reference，锁定对应的监视器。
规范规定对于每个类或接口C，都有一个唯一的初始化锁 LC，hotspot通过在VM的对象头中用2bit存储锁标志位。
{% asset_img sync.png hotspot对象锁状态 %}
获取锁失败线程阻塞等待对象锁被另一个线程释放，此过程的线程切换最耗费处理器时间。

##### 非阻塞同步
借助原子性的硬件命令cas实现一种乐观锁，防止线程挂起，cas的aba问题一是维护数据版本二是改用阻塞同步。

##### 无同步
方法内无线程共享数据，既不需要同步。java中可以通过ThreadLocal类实现线程本地存储。
每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，
以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，
每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。
如果数据只在一个线程中更改，则可用volatile来保证其他线程的可见性。

##### 代码是如何执行的

* .java源文件编译为.class文件
* jvm加载.class文件在虚拟机里执行，或者编译为机器码直接执行

执行时 程序计数器记录程序执行到哪
虚拟机栈（线程私有）里存放栈帧队列，第一个为当前执行信息，栈帧里有操作数栈用于存储方法信息


473 calc相加的解释